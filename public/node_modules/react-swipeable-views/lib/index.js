'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var React = require('react');
var ReactDOM = require('react-dom');
var PureRenderMixin = require('react-addons-pure-render-mixin');

var _require = require('react-motion');

var Motion = _require.Motion;
var spring = _require.spring;

var objectAssign = require('object-assign');

var styles = {
  root: {
    overflowX: 'hidden'
  },
  container: {
    display: 'flex'
  },
  slide: {
    width: '100%',
    flexShrink: 0,
    overflow: 'auto'
  }
};

var SwipeableViews = React.createClass({
  displayName: 'SwipeableViews',

  propTypes: {
    children: React.PropTypes.node,

    /**
     * If true disable touch events
     */
    disabled: React.PropTypes.bool,

    /**
     * This is the index of the slide to show.
     * This is useful when you want to change the default slide shown.
     * Or when you have tabs linked to each slide
     */
    index: React.PropTypes.number,

    /**
     * This is callback prop. It's call by the
     * component when the shown slide change after a swipe made by the user.
     * This is useful when you have tabs linked to each slide.
     */
    onChangeIndex: React.PropTypes.func,

    /**
     * This is the inlined style that will be applied
     * to each slide container.
     */
    style: React.PropTypes.object,

    /**
     * This is the threshold used for detecting a quick swipe.
     * If the computed speed is above this value, the index change.
     */
    threshold: React.PropTypes.number
  },
  mixins: [PureRenderMixin],
  getDefaultProps: function getDefaultProps() {
    return {
      index: 0,
      threshold: 5,
      disabled: false
    };
  },
  getInitialState: function getInitialState() {
    return {
      index: this.props.index,
      indexLatest: this.props.index,
      isDragging: false,
      isFirstRender: true
    };
  },
  componentDidMount: function componentDidMount() {
    this.setState({
      isFirstRender: false
    });
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    var index = nextProps.index;

    if (typeof index === 'number' && index !== this.props.index) {
      this.setState({
        index: index,
        indexLatest: index
      });
    }
  },
  slides: [],
  handleTouchStart: function handleTouchStart(event) {
    var touch = event.touches[0];

    this.startWidth = ReactDOM.findDOMNode(this).getBoundingClientRect().width;
    this.startIndex = this.state.index;
    this.startX = touch.pageX;
    this.lastX = touch.pageX;
    this.deltaX = 0;
    this.startY = touch.pageY;
    this.isScroll = undefined;
  },
  handleTouchMove: function handleTouchMove(event) {
    var touch = event.touches[0];

    // This is a one time test
    if (this.isScroll === undefined) {
      this.isScroll = Math.abs(this.startY - touch.pageY) > Math.abs(this.startX - touch.pageX);
    }

    if (this.isScroll) {
      return;
    }

    // Prevent native scrolling
    event.preventDefault();

    this.deltaX = this.deltaX * 0.5 + (touch.pageX - this.lastX) * 0.5;
    this.lastX = touch.pageX;

    var indexMax = React.Children.count(this.props.children) - 1;

    var index = this.startIndex + (this.startX - touch.pageX) / this.startWidth;

    if (index < 0) {
      index = 0;
      this.startX = touch.pageX;
    } else if (index > indexMax) {
      index = indexMax;
      this.startX = touch.pageX;
    }

    this.setState({
      isDragging: true,
      index: index
    });
  },
  handleTouchEnd: function handleTouchEnd() {
    if (this.isScroll) {
      return;
    }

    var indexNew = undefined;

    // Quick movement
    if (Math.abs(this.deltaX) > this.props.threshold) {
      if (this.deltaX > 0) {
        indexNew = Math.floor(this.state.index);
      } else {
        indexNew = Math.ceil(this.state.index);
      }
    } else {
      // Some hysteresis with startIndex
      if (Math.abs(this.startIndex - this.state.index) > 0.6) {
        indexNew = Math.round(this.state.index);
      } else {
        indexNew = this.startIndex;
      }
    }

    this.setState({
      index: indexNew,
      indexLatest: indexNew,
      isDragging: false
    });

    if (this.props.onChangeIndex && indexNew !== this.startIndex) {
      this.props.onChangeIndex(indexNew);
    }
  },
  getHeightSlide: function getHeightSlide(index) {
    var slide = this.slides[index];
    if (slide !== undefined) {
      var child = slide.children[0];
      if (child !== undefined) {
        return child.clientHeight;
      }
    }
    return 0;
  },
  renderContainer: function renderContainer(interpolatedStyle) {
    var _this = this;

    var _props = this.props;
    var children = _props.children;
    var style = _props.style;
    var isFirstRender = this.state.isFirstRender;

    this.slides = [];
    var childrenToRender = undefined;

    if (isFirstRender) {
      childrenToRender = React.createElement(
        'div',
        { ref: function (s) {
            return _this.slides[0] = s;
          }, style: styles.slide },
        React.Children.toArray(children)[0]
      );
    } else {
      childrenToRender = React.Children.map(children, function (element, i) {
        return React.createElement(
          'div',
          { ref: function (s) {
              return _this.slides[i] = s;
            }, style: styles.slide },
          element
        );
      });
    }

    return React.createElement(
      'div',
      { style: objectAssign({
          WebkitTransform: 'translate3d(-' + interpolatedStyle.translate + '%, 0, 0)',
          transform: 'translate3d(-' + interpolatedStyle.translate + '%, 0, 0)',
          height: interpolatedStyle.height
        }, styles.container, style) },
      childrenToRender
    );
  },
  render: function render() {
    var _this2 = this;

    var _props2 = this.props;
    var disabled = _props2.disabled;
    var style = _props2.style;
    var _state = this.state;
    var index = _state.index;
    var indexLatest = _state.indexLatest;
    var isDragging = _state.isDragging;

    var translate = index * 100;

    var height = 0;
    // There is no point to animate if we already provide a height
    if (!style || !style.height) {
      height = this.getHeightSlide(indexLatest);
    }

    var motionStyle = isDragging ? {
      translate: translate,
      height: height
    } : {
      translate: spring(translate, [300, 30]),
      height: height !== 0 ? spring(height, [300, 30]) : 0
    };

    var touchEvents = disabled ? {} : {
      onTouchStart: this.handleTouchStart,
      onTouchMove: this.handleTouchMove,
      onTouchEnd: this.handleTouchEnd
    };

    return React.createElement(
      'div',
      _extends({ style: styles.root }, touchEvents),
      React.createElement(
        Motion,
        { style: motionStyle },
        function (interpolatedStyle) {
          return _this2.renderContainer(interpolatedStyle);
        }
      )
    );
  }
});

module.exports = SwipeableViews;